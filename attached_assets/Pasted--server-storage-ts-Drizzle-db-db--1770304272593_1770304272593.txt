아래 코드를 server/storage.ts에 그대로 추가하세요.
단, 당신 프로젝트에서 Drizzle db 객체 이름이 db가 아닐 수도 있으니, 파일 상단에서 쓰는 이름(예: db, client, database)에 맞춰 변수명만 맞추면 됩니다.

Step 2: server/storage.ts — outputs 함수 5개 추가 (복붙용)
// server/storage.ts

import { and, desc, eq, gte, lte } from "drizzle-orm";
import { outputs, outputItems } from "../shared/schema";

// ✅ 프로젝트에 이미 있는 타입/DB 인스턴스에 맞게 조정:
// - this.db 가 있으면 this.db 사용
// - db가 있으면 db 사용
// 아래 코드는 "this.db" 기준으로 작성했습니다.

type CreateOutputInput = {
  userId: number;
  profileId: number;
  presetId: number;
  topic: string;
  outputType: "report" | "draft" | "alert";
  title: string;
  contentText: string;
  periodStart: Date;
  periodEnd: Date;
};

export class Storage {
  // ... 기존 코드

  // 1) 중복 생성 방지 체크
  async outputExists(profileId: number, periodStart: Date, periodEnd: Date): Promise<boolean> {
    const rows = await this.db
      .select({ id: outputs.id })
      .from(outputs)
      .where(and(eq(outputs.profileId, profileId), eq(outputs.periodStart, periodStart), eq(outputs.periodEnd, periodEnd)))
      .limit(1);

    return rows.length > 0;
  }

  // 2) outputs 생성
  async createOutput(input: CreateOutputInput): Promise<{ id: number }> {
    const rows = await this.db
      .insert(outputs)
      .values({
        userId: input.userId,
        profileId: input.profileId,
        presetId: input.presetId,
        topic: input.topic,
        outputType: input.outputType,
        title: input.title,
        contentText: input.contentText,
        periodStart: input.periodStart,
        periodEnd: input.periodEnd,
      })
      .returning({ id: outputs.id });

    return rows[0];
  }

  // 3) output_items 연결 (리포트에 포함된 item 기록)
  async linkOutputItems(outputId: number, itemIds: number[]): Promise<void> {
    if (!itemIds.length) return;

    // PK(outputId, itemId)라 중복 insert 시 에러 날 수 있음 → 우선 단순히 try/catch로 감싸도 됨
    await this.db.insert(outputItems).values(
      itemIds.map((itemId) => ({
        outputId,
        itemId,
      }))
    );
  }

  // 4) reports 목록 조회
  async listReports(params: { userId: number; profileId?: number; from?: Date; to?: Date }) {
    const whereClauses = [eq(outputs.userId, params.userId), eq(outputs.outputType, "report")];

    if (params.profileId) whereClauses.push(eq(outputs.profileId, params.profileId));
    if (params.from) whereClauses.push(gte(outputs.createdAt, params.from));
    if (params.to) whereClauses.push(lte(outputs.createdAt, params.to));

    return await this.db
      .select({
        id: outputs.id,
        title: outputs.title,
        createdAt: outputs.createdAt,
        periodStart: outputs.periodStart,
        periodEnd: outputs.periodEnd,
        profileId: outputs.profileId,
        topic: outputs.topic,
      })
      .from(outputs)
      .where(and(...whereClauses))
      .orderBy(desc(outputs.createdAt))
      .limit(50);
  }

  // 5) report 상세 조회
  async getReport(params: { userId: number; reportId: number }) {
    const rows = await this.db
      .select({
        id: outputs.id,
        title: outputs.title,
        contentText: outputs.contentText,
        createdAt: outputs.createdAt,
        periodStart: outputs.periodStart,
        periodEnd: outputs.periodEnd,
        profileId: outputs.profileId,
        topic: outputs.topic,
      })
      .from(outputs)
      .where(and(eq(outputs.id, params.reportId), eq(outputs.userId, params.userId), eq(outputs.outputType, "report")))
      .limit(1);

    return rows[0] ?? null;
  }

  // ... 기존 코드
}

✅ 바로 확인할 것 (간단)

TypeScript 에러 없이 빌드되는지

outputs, outputItems import 경로가 맞는지 (../shared/schema vs ../../shared/schema 등)

다음 스텝은 Step 3: server/jobs/report.ts를 새로 만들어 “profile 기준 report 생성”을 구현입니다.